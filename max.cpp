/*
ID: id
LANG: C++
TASK: task
*/
#include <bits/stdc++.h>
using namespace std;

// Enable 'indexed_set' data structure
/*
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
typedef tree<int,null_type,less<int>,
		rb_tree_tag,tree_order_statistics_node_update> indexed_set;
*/

using ll = long long; 
using ull = unsigned long long;
using ld = long double;

using pi = pair<int,int>;
using pl = pair<ll,ll>;

using vi = vector<int>;
using vpi = vector<pi>;

#define dspq priority_queue
#define umap unordered_map
#define uset unordered_set
#define whatIs(x) cout<<#x<<" = "<<x<<'\n'
#define all(x) (x).begin(),(x).end()
#define pb push_back
#define Ft first
#define Sd second

void setIO(string name = "") 
{
	cin.tie(nullptr)->sync_with_stdio(false); 
	if ((int)name.size()) {
		freopen((name + ".in").c_str(), "r", stdin);
		freopen((name + ".out").c_str(), "w", stdout);
	}
}

const int MOD = 1e9 + 7;
const ll INF = INT_MAX;
const ld PI = acos((ld)-1.0);

int main()
{
	setIO();
	// Starts here
	// Ends here
}
/*
    Problem Solving :                               Test cases:
   * overflow, array bounds                         *Special cases (N = 0/1/negative/large values)
   * do smth instead of nothing and stay organized  *Cases easily verifiable manually
   * don't get stuck on one approach                *Two identical test cases (in the same run)   
*/
